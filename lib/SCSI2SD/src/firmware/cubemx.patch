diff --git b/STM32CubeMX/SCSI2SD-V6/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_sd.c a/STM32CubeMX/SCSI2SD-V6/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_sd.c
index 4df41a0..7312d0e 100755
--- b/STM32CubeMX/SCSI2SD-V6/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_sd.c
+++ a/STM32CubeMX/SCSI2SD-V6/Drivers/STM32F2xx_HAL_Driver/Src/stm32f2xx_hal_sd.c
@@ -178,7 +178,6 @@
 
 /* Includes ------------------------------------------------------------------*/
 #include "stm32f2xx_hal.h"
-
 #ifdef HAL_SD_MODULE_ENABLED
 
 /** @addtogroup STM32F2xx_HAL_Driver
@@ -893,7 +892,7 @@ HAL_SD_ErrorTypedef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pRead
                                 SDIO_IT_STBITERR));
   
   /* Enable SDIO DMA transfer */
-  __HAL_SD_SDIO_DMA_ENABLE();
+  // MM disabled, as this fails on fast cards. __HAL_SD_SDIO_DMA_ENABLE();
   
   /* Configure DMA user callbacks */
   hsd->hdmarx->XferCpltCallback  = SD_DMA_RxCplt;
@@ -902,26 +901,29 @@ HAL_SD_ErrorTypedef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pRead
   /* Enable the DMA Stream */
   HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pReadBuffer, (uint32_t)(BlockSize * NumberOfBlocks)/4);
   
+  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
+  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
+  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
+  
   if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
   {
     BlockSize = 512;
     ReadAddr /= 512;
-  }
+  } else {
   
-  /* Set Block Size for Card */ 
-  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
-  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
-  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
-  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
-  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
-  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
+    /* Set Block Size for Card */ 
+    sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
+    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
+
+    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
   
-  /* Check for error conditions */
-  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
+    /* Check for error conditions */
+    errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
   
-  if (errorstate != SD_OK)
-  {
-    return errorstate;
+    if (errorstate != SD_OK)
+    {
+      return errorstate;
+    }
   }
   
   /* Configure the SD DPSM (Data Path State Machine) */ 
@@ -931,6 +933,11 @@ HAL_SD_ErrorTypedef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pRead
   sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
   sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
+
+  // We cannot enable DMA too early on UHS-I class 3 SD cards, or else the
+  // data is just discarded before the dpsm is started.
+  __HAL_SD_SDIO_DMA_ENABLE();
+
   SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   
   /* Check number of blocks command */
@@ -1017,28 +1024,30 @@ HAL_SD_ErrorTypedef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pWri
   HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pWriteBuffer, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BlockSize * NumberOfBlocks)/4);
 
   /* Enable SDIO DMA transfer */
-  __HAL_SD_SDIO_DMA_ENABLE();
+  // MM disabled, as this fails on fast cards. __HAL_SD_SDIO_DMA_ENABLE();
+  
+  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
+  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
+  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
   
   if (hsd->CardType == HIGH_CAPACITY_SD_CARD)
   {
     BlockSize = 512;
     WriteAddr /= 512;
-  }
+  } else {
+  	/* Set Block Size for Card */ 
+    sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
+    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
 
-  /* Set Block Size for Card */ 
-  sdio_cmdinitstructure.Argument         = (uint32_t)BlockSize;
-  sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCKLEN;
-  sdio_cmdinitstructure.Response         = SDIO_RESPONSE_SHORT;
-  sdio_cmdinitstructure.WaitForInterrupt = SDIO_WAIT_NO;
-  sdio_cmdinitstructure.CPSM             = SDIO_CPSM_ENABLE;
-  SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
+    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 
-  /* Check for error conditions */
-  errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
+    /* Check for error conditions */
+    errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCKLEN);
 
-  if (errorstate != SD_OK)
-  {
-    return errorstate;
+    if (errorstate != SD_OK)
+    {
+      return errorstate;
+    }
   }
   
   /* Check number of blocks command */
@@ -1049,13 +1058,34 @@ HAL_SD_ErrorTypedef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pWri
   }
   else
   {
+    /* MM: Prepare for write */
+    sdio_cmdinitstructure.Argument         = (uint32_t)(hsd->RCA << 16);
+    sdio_cmdinitstructure.CmdIndex         = SD_CMD_APP_CMD;
+    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
+    errorstate = SD_CmdResp1Error(hsd, SD_CMD_APP_CMD);
+    if (errorstate != SD_OK)
+    {
+      return errorstate;
+    }
+    sdio_cmdinitstructure.Argument         = (uint32_t)NumberOfBlocks;
+    sdio_cmdinitstructure.CmdIndex         = SD_CMD_SET_BLOCK_COUNT;
+    SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
+    errorstate = SD_CmdResp1Error(hsd, SD_CMD_SET_BLOCK_COUNT);
+    if (errorstate != SD_OK)
+    {
+      return errorstate;
+    }
+  
+    /* /MM */
+
     /* Send CMD25 WRITE_MULT_BLOCK with argument data address */
     sdio_cmdinitstructure.CmdIndex = SD_CMD_WRITE_MULT_BLOCK;
   }
-  
+
   sdio_cmdinitstructure.Argument         = (uint32_t)WriteAddr;
   SDIO_SendCommand(hsd->Instance, &sdio_cmdinitstructure);
 
+
   /* Check for error conditions */
   if(NumberOfBlocks > 1)
   {
@@ -1078,6 +1108,11 @@ HAL_SD_ErrorTypedef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint32_t *pWri
   sdio_datainitstructure.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
   sdio_datainitstructure.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
   sdio_datainitstructure.DPSM          = SDIO_DPSM_ENABLE;
+
+  // We cannot enable DMA too early on UHS-I class 3 SD cards, or else the
+  // data is just discarded before the dpsm is started.
+  __HAL_SD_SDIO_DMA_ENABLE();
+
   SDIO_DataConfig(hsd->Instance, &sdio_datainitstructure);
   
   hsd->SdTransferErr = errorstate;
@@ -1116,7 +1151,9 @@ HAL_SD_ErrorTypedef HAL_SD_CheckReadOperation(SD_HandleTypeDef *hsd, uint32_t Ti
   
   timeout = Timeout;
   
-  /* Wait until the Rx transfer is no longer active */
+  /* Wait until the Rx transfer is no longer active. IE. fifo is empty.
+Once FIFO is empty, the DMA will have finished and DmaTransferCplt should
+be true */
   while((__HAL_SD_SDIO_GET_FLAG(hsd, SDIO_FLAG_RXACT)) && (timeout > 0))
   {
     timeout--;  
@@ -1916,10 +1953,12 @@ HAL_SD_ErrorTypedef HAL_SD_HighSpeed (SD_HandleTypeDef *hsd)
     __HAL_SD_SDIO_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
     
     /* Test if the switch mode HS is ok */
-    if ((SD_hs[13]& 2) != 2)
-    {
-      errorstate = SD_UNSUPPORTED_FEATURE;
-    } 
+    // MM: These bits (0 to 271) are reserved in the spec I'm looking at ???
+    // Should be safe to ignore the result.
+    //if ((SD_hs[13]& 2) != 2)
+    //{
+      //errorstate = SD_UNSUPPORTED_FEATURE;
+    //} 
   }
   
   return errorstate;
diff --git b/STM32CubeMX/SCSI2SD-V6/Inc/stm32f2xx_hal_conf.h a/STM32CubeMX/SCSI2SD-V6/Inc/stm32f2xx_hal_conf.h
index ef23c94..c899300 100755
--- b/STM32CubeMX/SCSI2SD-V6/Inc/stm32f2xx_hal_conf.h
+++ a/STM32CubeMX/SCSI2SD-V6/Inc/stm32f2xx_hal_conf.h
@@ -76,7 +76,7 @@
 //#define HAL_SMARTCARD_MODULE_ENABLED   
 //#define HAL_WWDG_MODULE_ENABLED   
 #define HAL_PCD_MODULE_ENABLED
-//#define HAL_HCD_MODULE_ENABLED   
+#define HAL_HCD_MODULE_ENABLED
 #define HAL_GPIO_MODULE_ENABLED
 #define HAL_DMA_MODULE_ENABLED
 #define HAL_RCC_MODULE_ENABLED
diff --git b/STM32CubeMX/SCSI2SD-V6/Src/fsmc.c a/STM32CubeMX/SCSI2SD-V6/Src/fsmc.c
index c257924..5261aa9 100755
--- b/STM32CubeMX/SCSI2SD-V6/Src/fsmc.c
+++ a/STM32CubeMX/SCSI2SD-V6/Src/fsmc.c
@@ -66,12 +66,28 @@ void MX_FSMC_Init(void)
   hsram1.Init.AsynchronousWait = FSMC_ASYNCHRONOUS_WAIT_DISABLE;
   hsram1.Init.WriteBurst = FSMC_WRITE_BURST_DISABLE;
   /* Timing */
+
+  // 1 clock to read the address, + 1 for synchroniser skew
   Timing.AddressSetupTime = 2;
   Timing.AddressHoldTime = 1;
+
+  // Writes to device:
+  //   1 for synchroniser skew (dbx also delayed)
+  //   1 to skip hold time
+  //   1 to write data.
+
+  // Reads from device:
+  //   3 for syncroniser
+  //   1 to write back to fsmc bus.
   Timing.DataSetupTime = 4;
+
+  // Allow a clock for us to release signals
+  // Need to avoid both devices acting as outputs
+  // on the multiplexed lines at the same time.
   Timing.BusTurnAroundDuration = 1;
-  Timing.CLKDivision = 16;
-  Timing.DataLatency = 17;
+
+  Timing.CLKDivision = 16; // Ignored for async
+  Timing.DataLatency = 17; // Ignored for async
   Timing.AccessMode = FSMC_ACCESS_MODE_A;
   /* ExtTiming */
 
@@ -91,7 +107,7 @@ static void HAL_FSMC_MspInit(void){
   }
   FSMC_Initialized = 1;
   /* Peripheral clock enable */
-  #__FSMC_CLK_ENABLE();
+  __FSMC_CLK_ENABLE();
   
   /** FSMC GPIO Configuration  
   PE7   ------> FSMC_DA4
@@ -103,9 +119,6 @@ static void HAL_FSMC_MspInit(void){
   PE13   ------> FSMC_DA10
   PE14   ------> FSMC_DA11
   PE15   ------> FSMC_DA12
-  PD8   ------> FSMC_DA13
-  PD9   ------> FSMC_DA14
-  PD10   ------> FSMC_DA15
   PD14   ------> FSMC_DA0
   PD15   ------> FSMC_DA1
   PD0   ------> FSMC_DA2
@@ -113,28 +126,31 @@ static void HAL_FSMC_MspInit(void){
   PD4   ------> FSMC_NOE
   PD5   ------> FSMC_NWE
   PD7   ------> FSMC_NE1
+  PD8   ------> FSMC_DA13
+  PD9   ------> FSMC_DA14
+  PD10  ------> FSMC_DA15
   PB7   ------> FSMC_NL
   PE0   ------> FSMC_NBL0
   PE1   ------> FSMC_NBL1
   */
+  // MM: GPIO_SPEED_FREQ_MEDIUM is rated up to 50MHz, which is fine as all the
+  // fsmc timings are > 1 (ie. so clock speed / 2 is around 50MHz).
+
   /* GPIO_InitStruct */
-  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
-                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
-                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
+  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
   GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   GPIO_InitStruct.Pull = GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM; //HIGH;
   GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
 
   HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 
   /* GPIO_InitStruct */
-  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
-                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4 
-                          |GPIO_PIN_5|GPIO_PIN_7;
+  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1 
+                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
   GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   GPIO_InitStruct.Pull = GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM; //HIGH;
   GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
 
   HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
@@ -143,7 +159,7 @@ static void HAL_FSMC_MspInit(void){
   GPIO_InitStruct.Pin = GPIO_PIN_7;
   GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   GPIO_InitStruct.Pull = GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_MEDIUM;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;//HIGH;
   GPIO_InitStruct.Alternate = GPIO_AF12_FSMC;
 
   HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
@@ -186,9 +202,6 @@ static void HAL_FSMC_MspDeInit(void){
   PE13   ------> FSMC_DA10
   PE14   ------> FSMC_DA11
   PE15   ------> FSMC_DA12
-  PD8   ------> FSMC_DA13
-  PD9   ------> FSMC_DA14
-  PD10   ------> FSMC_DA15
   PD14   ------> FSMC_DA0
   PD15   ------> FSMC_DA1
   PD0   ------> FSMC_DA2
@@ -196,18 +209,18 @@ static void HAL_FSMC_MspDeInit(void){
   PD4   ------> FSMC_NOE
   PD5   ------> FSMC_NWE
   PD7   ------> FSMC_NE1
+  PD8   ------> FSMC_DA13
+  PD9   ------> FSMC_DA14
+  PD10  ------> FSMC_DA15
   PB7   ------> FSMC_NL
   PE0   ------> FSMC_NBL0
   PE1   ------> FSMC_NBL1
   */
 
-  HAL_GPIO_DeInit(GPIOE, GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
-                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
-                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1);
+  HAL_GPIO_DeInit(GPIOE, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);
 
-  HAL_GPIO_DeInit(GPIOD, GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
-                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4 
-                          |GPIO_PIN_5|GPIO_PIN_7);
+  HAL_GPIO_DeInit(GPIOD, GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1 
+                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10);
 
   HAL_GPIO_DeInit(GPIOB, GPIO_PIN_7);
 
diff --git b/STM32CubeMX/SCSI2SD-V6/Src/gpio.c a/STM32CubeMX/SCSI2SD-V6/Src/gpio.c
index 21529ff..5682f25 100755
--- b/STM32CubeMX/SCSI2SD-V6/Src/gpio.c
+++ a/STM32CubeMX/SCSI2SD-V6/Src/gpio.c
@@ -68,17 +68,17 @@ void MX_GPIO_Init(void)
   __GPIOB_CLK_ENABLE();
   __GPIOD_CLK_ENABLE();
 
-  /*Configure GPIO pins : PEPin PEPin PEPin */
+  /*Configure GPIO pins : PEPin PEPin PEPin PEPin */
   GPIO_InitStruct.Pin = FPGA_GPIO2_Pin|UNUSED_PE5_Pin|UNUSED_PE6_Pin;
   GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   GPIO_InitStruct.Pull = GPIO_PULLDOWN;
   HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 
-  /*Configure GPIO pin : PtPin */
+  /*Configure GPIO pin : PE3 */
   GPIO_InitStruct.Pin = FPGA_GPIO3_Pin;
   GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   GPIO_InitStruct.Pull = GPIO_NOPULL;
-  HAL_GPIO_Init(FPGA_GPIO3_GPIO_Port, &GPIO_InitStruct);
+  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 
   /*Configure GPIO pin : PE4 */
   GPIO_InitStruct.Pin = GPIO_PIN_4;
@@ -96,10 +96,8 @@ void MX_GPIO_Init(void)
   GPIO_InitStruct.Pull = GPIO_PULLDOWN;
   HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 
-  /*Configure GPIO pins : PAPin PAPin PAPin PAPin 
-                           PA10 */
-  GPIO_InitStruct.Pin = UNUSED_PA0_Pin|UNUSED_PA1_Pin|UNUSED_PA2_Pin|UNUSED_PA3_Pin 
-                          |GPIO_PIN_10;
+  /*Configure GPIO pins : PAPin PAPin PAPin PAPin */
+  GPIO_InitStruct.Pin = UNUSED_PA0_Pin|UNUSED_PA1_Pin|UNUSED_PA2_Pin|UNUSED_PA3_Pin;
   GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   GPIO_InitStruct.Pull = GPIO_PULLDOWN;
   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
@@ -125,14 +123,26 @@ void MX_GPIO_Init(void)
   GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
   HAL_GPIO_Init(nTERM_EN_GPIO_Port, &GPIO_InitStruct);
 
-  /*Configure GPIO pins : PBPin PBPin PBPin PB14 
-                           PB15 PBPin PBPin */
-  GPIO_InitStruct.Pin = BOOT1_Pin|UNUSED_PB12_Pin|UNUSED_PB13_Pin|GPIO_PIN_14 
-                          |GPIO_PIN_15|UNUSED_PB5_Pin|UNUSED_PB6_Pin;
+  /*Configure GPIO pins : PBPin PBPin PBPin */
+  GPIO_InitStruct.Pin = BOOT1_Pin|UNUSED_PB5_Pin|UNUSED_PB6_Pin;
+  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
+  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
+
+  /*Configure GPIO pins : PBPin PBPin */
+  GPIO_InitStruct.Pin = UNUSED_PB12_Pin|UNUSED_PB13_Pin;
   GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   GPIO_InitStruct.Pull = GPIO_PULLDOWN;
   HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 
+  /*Configure GPIO pins : PD6, PD12 */
+  // PD6: FSMC NWAIT, not used yet.PULLED UP in fpga pin config
+  // PD12: FPGA_GPIO1, not used.
+  GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_12;
+  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+  GPIO_InitStruct.Pull = GPIO_PULLUP;
+  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+
   /*Configure GPIO pins : PDPin PDPin */
   GPIO_InitStruct.Pin = UNUSED_PD11_Pin|FSMC_UNUSED_CLK_Pin;
   GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
@@ -160,11 +170,18 @@ void MX_GPIO_Init(void)
   GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 
-  /*Configure GPIO pin : PD6 */
-  GPIO_InitStruct.Pin = GPIO_PIN_6;
-  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
-  GPIO_InitStruct.Pull = GPIO_NOPULL;
-  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+  /*Configure GPIO pin : PA10 */
+  // USB Host OTG ID pin
+  GPIO_InitStruct.Pin = GPIO_PIN_10;
+  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
+  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
+
+  // USB Host pins, currently unused.
+  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
+  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
+  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 
   /*Configure GPIO pins : PBPin PBPin */
   GPIO_InitStruct.Pin = nSD_WP_Pin|nSD_CD_Pin;
diff --git b/STM32CubeMX/SCSI2SD-V6/Src/main.c a/STM32CubeMX/SCSI2SD-V6/Src/main.c
index 48e1f9a..a80e078 100755
--- b/STM32CubeMX/SCSI2SD-V6/Src/main.c
+++ a/STM32CubeMX/SCSI2SD-V6/Src/main.c
@@ -32,12 +32,10 @@
   */
 /* Includes ------------------------------------------------------------------*/
 #include "stm32f2xx_hal.h"
-#include "dma.h"
 #include "sdio.h"
 #include "spi.h"
-#include "tim.h"
 #include "usart.h"
 #include "usb_device.h"
 #include "gpio.h"
 #include "fsmc.h"

@@ -87,14 +87,10 @@ int main(void)
 
   /* Initialize all configured peripherals */
   MX_GPIO_Init();
-  MX_DMA_Init();
-  SystemClock_Config();
   MX_FSMC_Init();
   MX_SDIO_SD_Init();
   MX_SPI1_Init();
-  MX_TIM4_Init();
-  MX_USART3_UART_Init();
-  MX_USB_DEVICE_Init();
+  MX_USART3_UART_Init(); // Not used, but we don't want the pins floating.
 
   /* USER CODE BEGIN 2 */
   mainInit();
diff --git b/STM32CubeMX/SCSI2SD-V6/Src/sdio.c a/STM32CubeMX/SCSI2SD-V6/Src/sdio.c
index e8b2ad8..0f9a34b 100755
--- b/STM32CubeMX/SCSI2SD-V6/Src/sdio.c
+++ a/STM32CubeMX/SCSI2SD-V6/Src/sdio.c
@@ -36,7 +36,6 @@
 #include "sdio.h"
 
 #include "gpio.h"
-#include "dma.h"
 
 /* USER CODE BEGIN 0 */
 
@@ -59,9 +58,6 @@ void MX_SDIO_SD_Init(void)
   hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
   hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
   hsd.Init.ClockDiv = 0;
-  HAL_SD_Init(&hsd, &SDCardInfo);
-
-  HAL_SD_WideBusOperation_Config(&hsd, SDIO_BUS_WIDE_4B);
 
 }
 
@@ -143,6 +140,7 @@ void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
     __HAL_LINKDMA(hsd,hdmarx,hdma_sdio_rx);
 
     /* Peripheral interrupt init*/
+	HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
     HAL_NVIC_SetPriority(SDIO_IRQn, 0, 0);
     HAL_NVIC_EnableIRQ(SDIO_IRQn);
   /* USER CODE BEGIN SDIO_MspInit 1 */
diff --git b/STM32CubeMX/SCSI2SD-V6/Src/spi.c a/STM32CubeMX/SCSI2SD-V6/Src/spi.c
index cfb19ce..25e0745 100755
--- b/STM32CubeMX/SCSI2SD-V6/Src/spi.c
+++ a/STM32CubeMX/SCSI2SD-V6/Src/spi.c
@@ -54,6 +54,7 @@ void MX_SPI1_Init(void)
   hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
   hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
   hspi1.Init.NSS = SPI_NSS_SOFT;
+  // (96MHz / 2) / 4 = 12MHz. FPGA device allows up to 25MHz write
   hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
   hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
   hspi1.Init.TIMode = SPI_TIMODE_DISABLED;
diff --git b/STM32CubeMX/SCSI2SD-V6/Src/stm32f2xx_hal_msp.c a/STM32CubeMX/SCSI2SD-V6/Src/stm32f2xx_hal_msp.c
index e6b7783..b7ab0a3 100755
--- b/STM32CubeMX/SCSI2SD-V6/Src/stm32f2xx_hal_msp.c
+++ a/STM32CubeMX/SCSI2SD-V6/Src/stm32f2xx_hal_msp.c
@@ -50,14 +50,6 @@ void HAL_MspInit(void)
   HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 
   /* System interrupt init*/
-  /* MemoryManagement_IRQn interrupt configuration */
-  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
-  /* BusFault_IRQn interrupt configuration */
-  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
-  /* UsageFault_IRQn interrupt configuration */
-  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
-  /* DebugMonitor_IRQn interrupt configuration */
-  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
   /* SysTick_IRQn interrupt configuration */
   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 
diff --git b/STM32CubeMX/SCSI2SD-V6/Src/usbd_conf.c a/STM32CubeMX/SCSI2SD-V6/Src/usbd_conf.c
index 272d388..07387ca 100755
--- b/STM32CubeMX/SCSI2SD-V6/Src/usbd_conf.c
+++ a/STM32CubeMX/SCSI2SD-V6/Src/usbd_conf.c
@@ -108,7 +108,18 @@ void HAL_PCD_MspDeInit(PCD_HandleTypeDef* hpcd)
     PA11     ------> USB_OTG_FS_DM
     PA12     ------> USB_OTG_FS_DP 
     */
-    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_11|GPIO_PIN_12);
+	// HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_11|GPIO_PIN_12);
+	// MM: Don't let pins float.
+	GPIO_InitTypeDef GPIO_InitStruct;
+	GPIO_InitStruct.Pin = GPIO_PIN_9;
+	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
+	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
+
+	GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
+	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
+	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
+	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 
     /* Peripheral interrupt Deinit*/
     HAL_NVIC_DisableIRQ(OTG_FS_IRQn);
@@ -294,9 +305,11 @@ USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
   hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
   HAL_PCD_Init(&hpcd_USB_OTG_FS);
 
+  // Sum of all FIFOs must be <= 320.
   HAL_PCD_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
   HAL_PCD_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
-  HAL_PCD_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
+  HAL_PCD_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x40);
+  HAL_PCD_SetTxFiFo(&hpcd_USB_OTG_FS, 2, 0x40);
   }
   return USBD_OK;
 }
