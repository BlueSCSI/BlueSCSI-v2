; Copyright (c) 2011-2025 Bill Greiman
; This file is part of the SdFat library for SD memory cards.
;
; MIT License
;
; Permission is hereby granted, free of charge, to any person obtaining a
; copy of this software and associated documentation files (the "Software"),
; to deal in the Software without restriction, including without limitation
; the rights to use, copy, modify, merge, publish, distribute, sublicense,
; and/or sell copies of the Software, and to permit persons to whom the
; Software is furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included
; in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
; OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
; FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
; DEALINGS IN THE SOFTWARE.
;
; Online assembler used to produce PioSdioCard.pio.h
; https://wokwi.com/tools/pioasm
;
; --------------------------
;
; This file is based on PioSdioCard.pio from Bill Greiman's SdFat library,
; which is available here under MIT license: https://github.com/greiman/SdFat
; Copyright (c) 2024-2025 Tech by Androda LLC
; 
; Changes from Tech by Androda, LLC are licensed under the GPL version 3 or any later version.
; Original work by Bill Greiman uses the MIT License (shown above).
;
; https://www.gnu.org/licenses/gpl-3.0.html
; ----
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version. 
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details. 
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <https://www.gnu.org/licenses/>.

; State Machine 0 is for the Command / Response
; This State Machine will stall with clock low after sending a command and receiving the response
; Note that the FIFOs are set to 8 bit mode here, because 8 bits evenly divides all command and response sizes
.program cmd_rsp
.side_set 1 opt
.wrap_target
cmd_begin:
send_cmd:
    out pins, 1         side 0 [1]  ; When TX FIFO is empty, this command will stall with clock low
    jmp X-- send_cmd    side 1 [1]

    jmp !Y cmd_begin    side 0 [1]  ; If no response, go back to the beginning and stall
    set pindirs, 0      side 1 [3]
wait_resp:
    nop                 side 0 [3]
    nop                 side 1 [2]
    jmp PIN wait_resp               ; Run the SD clock until CMD pin goes low (First bit of response)
    
read_resp:
    in pins, 1          
    push iffull block   side 0 [2]  ; Read command response
    jmp Y-- read_resp   side 1 [1]
.wrap

% c-sdk {
static inline pio_sm_config pio_cmd_rsp_program_config(uint offset, uint cmd_pin, uint clk_pin, uint16_t div_int, uint8_t div_frac) {
    pio_sm_config c = cmd_rsp_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, clk_pin);
    sm_config_set_out_pins(&c, cmd_pin, 1);
    sm_config_set_in_pins(&c, cmd_pin);
    sm_config_set_set_pins(&c, cmd_pin, 1);
    sm_config_set_jmp_pin(&c, cmd_pin);
    sm_config_set_in_shift(&c, false, false, 8);
    sm_config_set_out_shift(&c, false, true, 8);
    sm_config_set_clkdiv_int_frac(&c, div_int, div_frac);
    return c;
}
%}

; Program which reads data and provides its own clock signal
; Use direct-execute PIO instructions to place the number of 4-bit nibbles to receive
; into the X register before enabling the state machine
.program rd_data_w_clock
.side_set 1
mov X, Y                side 0      ; Reinitialize number of nibbles to receive
wait_d0:
    nop                 side 0 [3]  ; Run the clock...
    jmp PIN wait_d0     side 1 [3]  ; Until the first response nibble (all zeroes)
    nop                 side 0 [2]  ; Clock transition low to make the SD card write out the first actual data nibble
    nop                 side 1 [1]  ; Transition clock high to stick data value
read_loop:
    in pins, 4          side 0 [2]  ; Read in the nibble and transition the clock low
    push iffull block   side 1      ; Transition the clock high and block execution if rx fifo is full
    jmp X--, read_loop  side 1      ; No delays here or previous instruction, because instr [1] = two instr execution time

% c-sdk {

static inline pio_sm_config pio_rd_data_w_clock_program_config(uint offset, uint d0_pin, uint clk_pin, float clk_div) {
  pio_sm_config c = rd_data_w_clock_program_get_default_config(offset);
  sm_config_set_sideset_pins(&c, clk_pin);
  sm_config_set_in_pins(&c, d0_pin);
  sm_config_set_jmp_pin(&c, d0_pin);
  sm_config_set_in_shift(&c, false, false, 32);
  sm_config_set_out_shift(&c, false, true, 32);
  sm_config_set_clkdiv(&c, clk_div);
  return c;
}
%}

; Program which writes data and provides its own clock signal
; Register X must be set properly, see calling code for details
; Register Y must be set to the number of CRC bits to receive (8/32)
.program sdio_tx_w_clock
.side_set 1 opt
tx_loop:
    out PINS, 4             side 0 [2]      ; Write nibble value and transition clock low
    jmp X-- tx_loop         side 1 [1]      ; Transition clock high, and check if more data needs to be sent

    set pindirs, 0          side 1 [2]      ; Set input mode to receive CRC token, without changing clock phase

crc_get:
    in pins, 1              side 1 [4]      ; Input the first bit of CRC response
    jmp Y-- crc_get         side 0 [4]      ; Read the CRC bits
bsy_wait:
    jmp PIN done            side 1 [4]
    jmp bsy_wait            side 0 [4]      ; Clock until no longer BSY
done:
.wrap_target
    push iffull noblock     side 0         ; Unconditional, just push the response token
.wrap

% c-sdk {
static inline pio_sm_config pio_sdio_tx_w_clock_program_config(uint offset, uint data_pin, uint clk_pin, int clk_div) {
    pio_sm_config c = sdio_tx_w_clock_program_get_default_config(offset);
    sm_config_set_sideset_pins(&c, clk_pin);
    sm_config_set_out_pins(&c, data_pin, 4);
    sm_config_set_in_pins(&c, data_pin);
    sm_config_set_set_pins(&c, data_pin, 4);
    sm_config_set_in_shift(&c, false, false, 8);
    sm_config_set_out_shift(&c, false, true, 32);
    sm_config_set_jmp_pin(&c, data_pin);
    sm_config_set_clkdiv_int_frac(&c, clk_div, 0);
    return c;
}
%}


